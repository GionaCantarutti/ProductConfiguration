<html>
	<head>
		<title>Rubik cube customizer</title>
		<style>
		
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
	
	</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
		<script src='lib/dat.gui.min.js'></script>
		<script src='lib/GLTFLoader.js'></script>
		<script src="lib/BufferGeometryUtils.js"></script>
	</head>
	<body>

		<script type="text/x-glsl" id="vertex">
		
			varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec2 uVv;

			attribute vec4 tangent;
			varying vec3 vTangent;
			varying vec3 vBitangent;

			void main() {
				vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
				vPosition = vPos.xyz;
				vNormal = normalize(normalMatrix * normal);

				vec3 objectTangent = vec3( tangent.xyz );
				vec3 transformedTangent = normalMatrix * objectTangent;
				vTangent = normalize( transformedTangent );
				// w is 1 or -1 depending on the sign of det( M tangent )
				vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

				uVv = uv;
				gl_Position = projectionMatrix * vPos;
			}

		</script>

		<script type="text/x-glsl" id="fragment">

			#define LIGHT_COUNT 2

			const float PI = 3.14159;

			varying vec3 vPosition;
			varying vec2 uVv;
			uniform vec3 pointLightPosition[LIGHT_COUNT]; // in world space
			uniform vec3 clight[LIGHT_COUNT];
			uniform sampler2D specularMap;
			uniform sampler2D diffuseMap;
			uniform sampler2D roughnessMap;
			uniform vec2 textureRepeat;

			varying vec3 vNormal;
			varying vec3 vTangent;
			varying vec3 vBitangent;
			uniform sampler2D normalMap;
			uniform vec2 normalScale;

			uniform samplerCube envMap;

			vec3 cdiff;
			vec3 cspec;
			float roughness;

			float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {

				float maxMIPLevelScalar = float( maxMIPLevel );

				float sigma = PI * roughness * roughness / ( 1.0 + roughness );
				float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );

				// clamp to allowable LOD ranges.
				return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );

			}

			vec3 FSchlick(float vDoth, vec3 f0) {
				return f0 + (vec3(1.0)-f0)*pow(1.0 - vDoth,5.0);
			}

			float DGGX(float NoH, float alpha) {
				float alpha2 = alpha * alpha;
				float k = NoH*NoH * (alpha2 - 1.0) + 1.0;
    			return alpha2 / (PI * k * k );
			}

			float G1(float nDotv, float alpha) {
				float alpha2 = alpha*alpha;
				return 2.0 * (nDotv / (nDotv + sqrt(alpha2 + (1.0-alpha2)*nDotv*nDotv )));
			}

			float GSmith(float nDotv, float nDotl, float alpha) {
				return G1(nDotl,alpha)*G1(nDotv,alpha);
			}

			vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
				return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
			}

			void main() {

				vec3 outRadiance = vec3(0, 0, 0);
				vec3 another = vec3(0, 0, 0);

				for (int i = 0; i < LIGHT_COUNT; i++) {

					vec4 lPosition = viewMatrix * vec4( pointLightPosition[i], 1.0 );
					vec3 l = normalize(lPosition.xyz - vPosition.xyz);

					vec3 normal = normalize( vNormal );
					vec3 tangent = normalize( vTangent );
					vec3 bitangent = normalize( vBitangent );
					mat3 vTBN = mat3( tangent, bitangent, normal );
					vec3 mapN = texture2D( normalMap, uVv ).xyz * 2.0 - 1.0;
					vec3 n = normalize( vTBN * mapN );

					vec3 v = normalize( -vPosition);
					vec3 h = normalize( v + l);
					// small quantity to prevent divisions by 0
					float nDotl = max(dot( n, l ),0.000001);
					float lDoth = max(dot( l, h ),0.000001);
					float nDoth = max(dot( n, h ),0.000001);
					float vDoth = max(dot( v, h ),0.000001);
					float nDotv = max(dot( n, v ),0.000001);

					cdiff = texture2D( diffuseMap, uVv*textureRepeat ).rgb;
					// texture in sRGB, linearize
					cdiff = pow( cdiff, vec3(2.2));
					cspec = texture2D( specularMap, uVv*textureRepeat ).rgb;
					// texture in sRGB, linearize
					cspec = pow( cspec, vec3(2.2));
					roughness = texture2D( roughnessMap, uVv*textureRepeat).r; // no need to linearize roughness map
					vec3 fresnel = FSchlick(vDoth, cspec);
					float alpha = roughness * roughness;
					vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl, alpha)*DGGX(nDoth,alpha)/
						(4.0*nDotl*nDotv);

					vec3 vReflect = reflect(vPosition,n);
					float specularMIPLevel = getSpecularMIPLevel(alpha,8 );
					vec3 r = inverseTransformDirection( vReflect, viewMatrix );

					vec3 envLight = textureCubeLodEXT( envMap, vec3(-r.x, r.yz), specularMIPLevel ).rgb;
					envLight = pow( envLight, vec3(2.2));
						
					outRadiance = outRadiance + (envLight*PI* clight[i] * nDotl * BRDF );
					//another = n;

				}

				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
				//gl_FragColor = vec4(another, 1.0);
			}
		
		</script>

		<script type="text/x-glsl" id="stickerVertex">
		
			varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec2 uVv;

			void main() {
				vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
				vPosition = vPos.xyz;
				vNormal = normalize(normalMatrix * normal);

				uVv = uv;
				gl_Position = projectionMatrix * vPos;
			}

		</script>

		<script type="text/x-glsl" id="stickerFragment">

			#define LIGHT_COUNT 2

			const float PI = 3.14159;

			varying vec3 vPosition;
			varying vec2 uVv;
			uniform vec3 pointLightPosition[LIGHT_COUNT]; // in world space
			uniform vec3 clight[LIGHT_COUNT];
			uniform vec3 cspec;
			uniform sampler2D diffuseMap;
			uniform vec2 textureRepeat;
			uniform float roughness;

			varying vec3 vNormal;

			uniform samplerCube envMap;

			vec3 cdiff;

			float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {

				float maxMIPLevelScalar = float( maxMIPLevel );

				float sigma = PI * roughness * roughness / ( 1.0 + roughness );
				float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );

				// clamp to allowable LOD ranges.
				return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );

			}

			vec3 FSchlick(float vDoth, vec3 f0) {
				return f0 + (vec3(1.0)-f0)*pow(1.0 - vDoth,5.0);
			}

			float DGGX(float NoH, float alpha) {
				float alpha2 = alpha * alpha;
				float k = NoH*NoH * (alpha2 - 1.0) + 1.0;
    			return alpha2 / (PI * k * k );
			}

			float G1(float nDotv, float alpha) {
				float alpha2 = alpha*alpha;
				return 2.0 * (nDotv / (nDotv + sqrt(alpha2 + (1.0-alpha2)*nDotv*nDotv )));
			}

			float GSmith(float nDotv, float nDotl, float alpha) {
				return G1(nDotl,alpha)*G1(nDotv,alpha);
			}

			vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
				return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
			}

			void main() {

				vec3 outRadiance = vec3(0, 0, 0);
				vec3 another = vec3(0, 0, 0);

				for (int i = 0; i < LIGHT_COUNT; i++) {

					vec4 lPosition = viewMatrix * vec4( pointLightPosition[i], 1.0 );
					vec3 l = normalize(lPosition.xyz - vPosition.xyz);

					vec3 n = normalize( vNormal );

					vec3 v = normalize( -vPosition);
					vec3 h = normalize( v + l);
					// small quantity to prevent divisions by 0
					float nDotl = max(dot( n, l ),0.000001);
					float lDoth = max(dot( l, h ),0.000001);
					float nDoth = max(dot( n, h ),0.000001);
					float vDoth = max(dot( v, h ),0.000001);
					float nDotv = max(dot( n, v ),0.000001);

					cdiff = texture2D( diffuseMap, uVv*textureRepeat ).rgb;
					// texture in sRGB, linearize
					cdiff = pow( cdiff, vec3(2.2));
					vec3 fresnel = FSchlick(vDoth, cspec);
					float alpha = roughness * roughness;
					vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl, alpha)*DGGX(nDoth,alpha)/
						(4.0*nDotl*nDotv);

					vec3 vReflect = reflect(vPosition,n);
					float specularMIPLevel = getSpecularMIPLevel(alpha,8 );
					vec3 r = inverseTransformDirection( vReflect, viewMatrix );

					vec3 envLight = textureCubeLodEXT( envMap, vec3(-r.x, r.yz), specularMIPLevel ).rgb;
					envLight = pow( envLight, vec3(2.2));
						
					outRadiance = outRadiance + (envLight*PI* clight[i] * nDotl * BRDF );
					//another = n;

				}

				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
				//gl_FragColor = vec4(another, 1.0);
			}
		
		</script>

		<script>
		
		var scene, camera, renderer, controls, stats;

        var lastFrameTime;
        var deltaTime;

        var xCubes, yCubes, zCubes;
        var cubeSize;
		var cubeSpacing;
		
		var stickerMargin;
		var stickerSpacing;

		var defaultMat;
		var stickerDefaultMat;

		var cubes;
		
		var mouse = new THREE.Vector2();
		var raycaster = new THREE.Raycaster();

		var selectedCube;

		var materialBrush;

		var stickerRotations = [
			[0, 0, 0],
			[0, 0, 1.57079],
			[0, 0, 3.14159],
			[0, 0, 4.71238],
			[0, 1.57079, 0],
			[0, 4.71238, 0]
		];

		var facingCube = [
			[+1, 0, 0],
			[0, +1, 0],
			[-1, 0, 0],
			[0, -1, 0],
			[0, 0, -1],
			[0, 0, +1],
		];

		var uvAxisOrder = [
			[0, 1, 2],
			[2, 0, 1],
			[0, 2, 1],
			[1, 0, 2],
			[2, 1, 0],
			[1, 2, 0],
		];

		var cubeCenter;
		var pivots = [];

		function Start() {

			var loader = new THREE.TextureLoader();
			const tex = loader.load( 'http://localhost:8080/images/Portrait.jpg' );


			var matName = "Wood_StaggeredFloorPlanks";
			var diffuseMap = loader.load( "http://localhost:8080/textures/" + matName + "_Diffuse.png" );
			var specularMap = loader.load( "http://localhost:8080/textures/" + matName + "_Specular.png" );
			var roughnessMap = loader.load( "http://localhost:8080/textures/" + matName + "_Roughness.png" );
			var normalMap = loader.load( "http://localhost:8080/textures/" + matName + "_Normal.png" );

			const cubeLoader = new THREE.CubeTextureLoader();
			const skybox = cubeLoader.load( [
			'http://localhost:8080/textures/cubemap/posx.png',
			'http://localhost:8080/textures/cubemap/negx.png',
			'http://localhost:8080/textures/cubemap/posy.png',
			'http://localhost:8080/textures/cubemap/negy.png',
			'http://localhost:8080/textures/cubemap/posz.png',
			'http://localhost:8080/textures/cubemap/negz.png'
			]);

			var uniforms = {
						specularMap: {value: specularMap},
						diffuseMap:	{value: diffuseMap},
						roughnessMap:	{value: roughnessMap},
						normalMap: {value: normalMap},
						normalScale: {value: new THREE.Vector2(1,1)},
						pointLightPosition:	{ value: [
							new THREE.Vector3(5, 5, 5),
							new THREE.Vector3(-5, -6, -9)
						] },
						clight:	{ value: [
							new THREE.Vector3(3, 3, 3),
							new THREE.Vector3(2, 2, 2)
						] },
						textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) },
						envMap: { value: skybox }
					};

			vs = document.getElementById("vertex").textContent;
			fs = document.getElementById("fragment").textContent;

			materialExtensions = {
				shaderTextureLOD: true // set to use shader texture LOD
			};

			defaultMat = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs, fragmentShader: fs, extensions: materialExtensions});
			defaultMat.vertexTangents = true;

			var stickerUniforms = {
						cspec: {value: new THREE.Vector3(0.2, 0.2, 0.2)},
						diffuseMap:	{value: tex},
						roughness:	{value: 0.5},
						pointLightPosition:	{ value: [
							new THREE.Vector3(5, 5, 5),
							new THREE.Vector3(-5, -6, -9)
						] },
						clight:	{ value: [
							new THREE.Vector3(3, 3, 3),
							new THREE.Vector3(2, 2, 2)
						] },
						textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) },
						envMap: { value: skybox }
					};

			svs = document.getElementById("stickerVertex").textContent;
			sfs = document.getElementById("stickerFragment").textContent;

			materialExtensions = {
				shaderTextureLOD: true // set to use shader texture LOD
			};

			stickerDefaultMat = new THREE.ShaderMaterial({ uniforms: stickerUniforms, vertexShader: svs, fragmentShader: sfs, extensions: materialExtensions});

			window.addEventListener( 'mousemove', onMouseMove, false );
			window.addEventListener( 'click', onMouseClick, false );

			lastFrameTime = Date.now();

			materialBrush = new THREE.MeshBasicMaterial( {color: 0xff0000 } );

			//Boilerplate
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 90, window.innerWidth / window.innerHeight, 0.1, 1000 );

			scene.background = skybox;

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0xf0f0f0 );
			document.body.appendChild( renderer.domElement );

			//Camera settings
			camera.position.set(3,4,6);
			camera.lookAt( new THREE.Vector3(0,0,0));

			xCubes = 5; yCubes = 5; zCubes = 5;
			cubeSize = 0.5;
			cubeSpacing = 0.3;
			stickerMargin = 0.05;
			stickerSpacing = 0.0001;

			//defaultMat = new THREE.MeshBasicMaterial( {color: 0xFF0000} );

			CreateCube();

			cubeCenter.position.set(0,0,0);

			//Stats
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );

			controls = new THREE.OrbitControls( camera );
			controls.addEventListener( 'change', Render );


		}

        function CreateCube() {

			cubes = [];
			cubeCenter = new THREE.Group();
			scene.add(cubeCenter);
			cubeCenter.position.set((xCubes / 2.0) * (cubeSize + cubeSpacing), (yCubes / 2.0) * (cubeSize + cubeSpacing), (zCubes / 2.0) * (cubeSize + cubeSpacing));

			for(let i = 0; i < 6; i++) {
				var newPivot = new THREE.Object3D();
				//scene.add(newPivot);
				cubeCenter.add(newPivot);

				newPivot.position = new THREE.Vector3(cubeSize + (cubeSpacing));
				pivots.push(newPivot);
			}

            var x, y, z;
            for (x = 0; x < xCubes; x++) {
				var xArr = [];
				cubes[x] = xArr;
                for (y = 0; y < yCubes; y++) {
					var yArr = [];
					cubes[x][y] = yArr;
                    for (z = 0; z < zCubes; z++) {

                        var cubeGeo = new THREE.BoxBufferGeometry(cubeSize, cubeSize, cubeSize);
                        var newCube = new THREE.Mesh( cubeGeo, defaultMat );

						THREE.BufferGeometryUtils.computeTangents(cubeGeo);

                        newCube.position.set(((x + 0.5) * cubeSize) + (cubeSpacing * x), ((y + 0.5) * cubeSize) + (cubeSpacing * y), ((z + 0.5) * cubeSize) + (cubeSpacing * z));

						//scene.add( newCube );

						cubes[x][y][z] = newCube;

						cubeCenter.add(newCube);
						newCube.position.sub(cubeCenter.position);

                    }
                }
			}
			
			AttachStickers();

		}

		function AttachStickers() {

			var xl = 1.0 / xCubes;
			var yl = 1.0 / yCubes;
			var zl = 1.0 / zCubes;

			var x, y, z;
            for (x = 0; x < xCubes; x++) {
                for (y = 0; y < yCubes; y++) {
                    for (z = 0; z < zCubes; z++) {

						var currentCube = cubes[x][y][z];
						
						for (let i = 0; i < 6; i++) {

							//Very convoluted way to check if the current face is pointed outside the cube (to not place stickers in-between cubes)
							if ((typeof cubes[x + facingCube[i][0]] === 'undefined') || (typeof cubes[x + facingCube[i][0]][y + facingCube[i][1]] === 'undefined') || (typeof cubes[x + facingCube[i][0]][y + facingCube[i][1]][z + facingCube[i][2]] === 'undefined') ) {

								var quadGeo = new THREE.Geometry();

								var cubeRadius = cubeSize/2.0;

								var side = cubeRadius - stickerMargin;
								var radius = cubeRadius + stickerSpacing;

								var vertexPos = [
									[
										[radius, -side, -side],
										[radius, side, -side],
										[radius, side, side],
										[radius, -side, side],
									],
									[
										[-side, radius, -side],
										[-side, radius, side],
										[side, radius, side],
										[side, radius, -side],
									],
									[
										[-radius, -side, -side],
										[-radius, -side, side],
										[-radius, side, side],
										[-radius, side, -side],
									],
									[
										[-side, -radius, -side],
										[side, -radius, -side],
										[side, -radius, side],
										[-side, -radius, side],
									],
									[
										[-side, -side, -radius],
										[-side, side, -radius],
										[side, side, -radius],
										[side, -side, -radius],
									],
									[
										[-side, -side, radius],
										[side, -side, radius],
										[side, side, radius],
										[-side, side, radius],
									],
								];

								quadGeo.vertices.push(
									new THREE.Vector3(vertexPos[i][0][0], vertexPos[i][0][1], vertexPos[i][0][2]),
									new THREE.Vector3(vertexPos[i][1][0], vertexPos[i][1][1], vertexPos[i][1][2]),
									new THREE.Vector3(vertexPos[i][2][0], vertexPos[i][2][1], vertexPos[i][2][2]),
									new THREE.Vector3(vertexPos[i][3][0], vertexPos[i][3][1], vertexPos[i][3][2])
								)

								quadGeo.faces.push(
									new THREE.Face3(0, 1, 2),
									new THREE.Face3(0, 2, 3)
								)

								var au, bu, cu, du;
								var av, bv, cv, dv;

								if (uvAxisOrder[i][0] == 1) {
									au = xl * x;
									bu = xl * (x+1);
									cu = xl * (x+1);
									du = xl * x;
								} else if (uvAxisOrder[i][1] == 1) {
									au = yl * y;
									bu = yl * (y+1);
									cu = yl * (y+1);
									du = yl * y;
								} else if (uvAxisOrder[i][2] == 1) {
									au = zl * z;
									bu = zl * (z+1);
									cu = zl * (z+1);
									du = zl * z;
								}

								if (uvAxisOrder[i][0] == 2) {
									av = xl * x;
									bv = xl * x;
									cv = xl * (x+1);
									dv = xl * (x+1);
								} else if (uvAxisOrder[i][1] == 2) {
									av = yl * y;
									bv = yl * y;
									cv = yl * (y+1);
									dv = yl * (y+1);
								} else if (uvAxisOrder[i][2] == 2) {
									av = zl * z;
									bv = zl * z;
									cv = zl * (z+1);
									dv = zl * (z+1);
								}

								quadGeo.faceVertexUvs[0] = [];

								/*
								quadGeo.faceVertexUvs[0].push(
									new THREE.Vector2(au, av),
									new THREE.Vector2(bu, bv),
									new THREE.Vector2(cu, cv),
									new THREE.Vector2(du, dv),
								)
								*/

								quadGeo.faceVertexUvs[0].push(
									[
										new THREE.Vector2(au, av),
										new THREE.Vector2(bu, bv),
										new THREE.Vector2(cu, cv),
									],
									[
										new THREE.Vector2(au, av),
										new THREE.Vector2(cu, cv),
										new THREE.Vector2(du, dv),
									]
								)

								quadGeo.uvsNeedUpdate = true;
								quadGeo.computeVertexNormals();

								var sticker = new THREE.Mesh(quadGeo, stickerDefaultMat);

								//scene.add(sticker);

								currentCube.add(sticker);
								sticker.position.set(0,0,0);


							}

						}

                    }
                }
			}

		}

		function onMouseClick() {

			if (typeof scene != "undefined") {

				raycaster.setFromCamera(mouse, camera);
				var intersects = raycaster.intersectObjects( scene.children, true );

				if (intersects.length > 0) {
					selectedCube = intersects[0];

					selectedCube.object.material = materialBrush;

					//selectedCube.object.position.set(0, 0, 0);
				}


			}
		}
		
		function onMouseMove() {
			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		}
		
		function Update() {

            deltaTime = Date.now() - lastFrameTime;
			lastFrameTime = Date.now();
			
			//cubeCenter.rotateY(0.001);

			requestAnimationFrame( Update );
			stats.update();
			controls.update();
            Render();

        }
        
		function Render() {
			
			renderer.render(scene, camera);
		}
		
		Start();
		Update();
			
		</script>
	</body>
</html>