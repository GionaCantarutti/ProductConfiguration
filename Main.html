<html>
	<head>
		<title>Rubik cube customizer</title>
		<style>
		
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
	
	</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
	</head>
	<body>

		<script>
		
		var scene, camera, renderer, controls, stats;

        var lastFrameTime;
        var deltaTime;

        var xCubes, yCubes, zCubes;
        var cubeSize;
		var cubeSpacing;
		
		var stickerMargin;
		var stickerSpacing;

		var defaultMat;
		var stickerDefaultMat;

		var cubes;
		

		var mouse = new THREE.Vector2();
		var raycaster = new THREE.Raycaster();

		var selectedCube;

		var materialBrush;

		var stickerRotations = [
			[0, 0, 0],
			[0, 0, 1.57079],
			[0, 0, 3.14159],
			[0, 0, 4.71238],
			[0, 1.57079, 0],
			[0, 4.71238, 0]
		];

		var facingCube = [
			[+1, 0, 0],
			[0, +1, 0],
			[-1, 0, 0],
			[0, -1, 0],
			[0, 0, -1],
			[0, 0, +1],
		];

		var uvAxisOrder = [
			[0, 1, 2],
			[2, 0, 1],
			[0, 2, 1],
			[1, 0, 2],
			[2, 1, 0],
			[1, 2, 0],
		];

		var cubeCenter = new THREE.Object3D();
		var pivots = [];

        function CreateCube() {

			cubes = [];
			scene.add(cubeCenter);
			cubeCenter.position.set((xCubes / 2.0) * (cubeSize + cubeSpacing), (yCubes / 2.0) * (cubeSize + cubeSpacing), (zCubes / 2.0) * (cubeSize + cubeSpacing));

			for(let i = 0; i < 6; i++) {
				var newPivot = new THREE.Object3D();
				scene.add(newPivot);
				newPivot.parent = cubeCenter;

				newPivot.position = new THREE.Vector3(cubeSize + (cubeSpacing));
				pivots.push(newPivot);
			}

            var x, y, z;
            for (x = 0; x < xCubes; x++) {
				var xArr = [];
				cubes[x] = xArr;
                for (y = 0; y < yCubes; y++) {
					var yArr = [];
					cubes[x][y] = yArr;
                    for (z = 0; z < zCubes; z++) {

                        var cubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
                        var newCube = new THREE.Mesh( cubeGeo, defaultMat );

                        newCube.position.set(((x + 0.5) * cubeSize) + (cubeSpacing * x), ((y + 0.5) * cubeSize) + (cubeSpacing * y), ((z + 0.5) * cubeSize) + (cubeSpacing * z))

						scene.add( newCube );

						cubes[x][y][z] = newCube;

						newCube.parent = cubeCenter;
						newCube.position.sub(cubeCenter.position);

                    }
                }
			}
			
			AttachStickers();

		}

		function AttachStickers() {

			var xl = 1.0 / xCubes;
			var yl = 1.0 / yCubes;
			var zl = 1.0 / zCubes;

			var x, y, z;
            for (x = 0; x < xCubes; x++) {
                for (y = 0; y < yCubes; y++) {
                    for (z = 0; z < zCubes; z++) {

						var currentCube = cubes[x][y][z];
						
						for (let i = 0; i < 6; i++) {

							//Very convoluted way to check if the current face is pointed outside the cube (to not place stickers in-between cubes)
							if ((typeof cubes[x + facingCube[i][0]] === 'undefined') || (typeof cubes[x + facingCube[i][0]][y + facingCube[i][1]] === 'undefined') || (typeof cubes[x + facingCube[i][0]][y + facingCube[i][1]][z + facingCube[i][2]] === 'undefined') ) {

								var quadGeo = new THREE.Geometry();

								var cubeRadius = cubeSize/2.0;

								var side = cubeRadius - stickerMargin;
								var radius = cubeRadius + stickerSpacing;

								var vertexPos = [
									[
										[radius, -side, -side],
										[radius, side, -side],
										[radius, side, side],
										[radius, -side, side],
									],
									[
										[-side, radius, -side],
										[-side, radius, side],
										[side, radius, side],
										[side, radius, -side],
									],
									[
										[-radius, -side, -side],
										[-radius, -side, side],
										[-radius, side, side],
										[-radius, side, -side],
									],
									[
										[-side, -radius, -side],
										[side, -radius, -side],
										[side, -radius, side],
										[-side, -radius, side],
									],
									[
										[-side, -side, -radius],
										[-side, side, -radius],
										[side, side, -radius],
										[side, -side, -radius],
									],
									[
										[-side, -side, radius],
										[side, -side, radius],
										[side, side, radius],
										[-side, side, radius],
									],
								];

								quadGeo.vertices.push(
									new THREE.Vector3(vertexPos[i][0][0], vertexPos[i][0][1], vertexPos[i][0][2]),
									new THREE.Vector3(vertexPos[i][1][0], vertexPos[i][1][1], vertexPos[i][1][2]),
									new THREE.Vector3(vertexPos[i][2][0], vertexPos[i][2][1], vertexPos[i][2][2]),
									new THREE.Vector3(vertexPos[i][3][0], vertexPos[i][3][1], vertexPos[i][3][2])
								)

								quadGeo.faces.push(
									new THREE.Face3(0, 1, 2),
									new THREE.Face3(0, 2, 3)
								)

								var au, bu, cu, du;
								var av, bv, cv, dv;

								if (uvAxisOrder[i][0] == 1) {
									au = xl * x;
									bu = xl * (x+1);
									cu = xl * (x+1);
									du = xl * x;
								} else if (uvAxisOrder[i][1] == 1) {
									au = yl * y;
									bu = yl * (y+1);
									cu = yl * (y+1);
									du = yl * y;
								} else if (uvAxisOrder[i][2] == 1) {
									au = zl * z;
									bu = zl * (z+1);
									cu = zl * (z+1);
									du = zl * z;
								}

								if (uvAxisOrder[i][0] == 2) {
									av = xl * x;
									bv = xl * x;
									cv = xl * (x+1);
									dv = xl * (x+1);
								} else if (uvAxisOrder[i][1] == 2) {
									av = yl * y;
									bv = yl * y;
									cv = yl * (y+1);
									dv = yl * (y+1);
								} else if (uvAxisOrder[i][2] == 2) {
									av = zl * z;
									bv = zl * z;
									cv = zl * (z+1);
									dv = zl * (z+1);
								}

								quadGeo.faceVertexUvs[0] = [];

								/*
								quadGeo.faceVertexUvs[0].push(
									new THREE.Vector2(au, av),
									new THREE.Vector2(bu, bv),
									new THREE.Vector2(cu, cv),
									new THREE.Vector2(du, dv),
								)
								*/

								quadGeo.faceVertexUvs[0].push(
									[
										new THREE.Vector2(au, av),
										new THREE.Vector2(bu, bv),
										new THREE.Vector2(cu, cv),
									],
									[
										new THREE.Vector2(au, av),
										new THREE.Vector2(cu, cv),
										new THREE.Vector2(du, dv),
									]
								)

								quadGeo.uvsNeedUpdate = true;

								var sticker = new THREE.Mesh(quadGeo, stickerDefaultMat);

								scene.add(sticker);

								sticker.parent = currentCube;
								sticker.position.set(0,0,0);


							}

						}

                    }
                }
			}

		}
		
		function Start() {

			const tex = new THREE.TextureLoader().load( 'http://localhost:8080/images/Portrait.jpg' );

			stickerDefaultMat = new THREE.MeshBasicMaterial( {
				map: tex
			} )

			window.addEventListener( 'mousemove', onMouseMove, false );
			window.addEventListener( 'click', onMouseClick, false );

			lastFrameTime = Date.now();
			
			//materialBrush = new THREE.MeshBasicMaterial( {color: 0xff0000 } );

            //Boilerplate
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0xf0f0f0 );
			document.body.appendChild( renderer.domElement );
			
            //Camera settings
			camera.position.set(3,4,6);
			camera.lookAt( new THREE.Vector3(0,0,0));

            //Skybox
            /*
            const loader = new THREE.CubeTextureLoader();
            const skybox = loader.load( [
            'http://localhost:8080/Front.jpg',
            'http://localhost:8080/Side.jpg',
            'http://localhost:8080/Top.jpg',
            'http://localhost:8080/Bottom.jpg',
            'http://localhost:8080/Side.jpg',
            'http://localhost:8080/Side.jpg'
            ]);

            scene.background = skybox;
            */

            xCubes = 3; yCubes = 3; zCubes = 3;
            cubeSize = 1;
			cubeSpacing = 0.02;
			stickerMargin = 0.05;
			stickerSpacing = 0.0001;

            //defaultMat = new THREE.MeshBasicMaterial( {color: 0xFF0000} );

            CreateCube();
			
            //Stats
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );
			
			// uncomment if you need to draw coordinate axes when building the scene
			Coordinates.drawAllAxes();
			
			controls = new THREE.OrbitControls( camera );
			controls.addEventListener( 'change', Render );
			
			
		}

		function onMouseClick() {
			raycaster.setFromCamera(mouse, camera);
			var intersects = raycaster.intersectObjects( scene.children );

			if (intersects.length > 0) {
				selectedCube = intersects[0];
			}

			selectedCube.object.material = materialBrush;

			//selectedCube.object.position.set(0, 0, 0);
		}
		
		function onMouseMove() {
			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		}
		
		function Update() {

            deltaTime = Date.now() - lastFrameTime;
			lastFrameTime = Date.now();
			
			//cubeCenter.rotateY(0.001);

			requestAnimationFrame( Update );
			stats.update();
			controls.update();
            Render();

        }
        
		function Render() {
			
			renderer.render(scene, camera);
		}
		
		Start();
		Update();
			
		</script>
	</body>
</html>